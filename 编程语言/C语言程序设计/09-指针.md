# 09-指针

## 一 指针概述

指针是一种数据类型，其实质就是内存地址。在开发中如果要使用一些数据的内存地址，需要用一个变量来保存该地址，这个变量称为指针变量。

```c++
    int a = 0;
    printf("%p \n",&a);      // &a 查看a的地址

    // *p 定义指针变量
    int *p = NULL;              // p是变量名， int * 是指针类型
    p = &a;               // 将a的地址赋值给p
    printf("%d \n",*p);   // p指向了a的地址，*p就是a的值

    // 通过指针间接修改变量的值
    *p = 100;
    printf("%d \n",*p);
```

指针使用贴士：

- 声明指针时，`*` 表示所声明的变量为指针类型
- 使用指针时，`*` 表示操作指针所指向的内存空间

## 二 指针一些常识

### 2.1 sizeof()测量指针大小

使用 sizeof()可以测量指针的大小，得到的总是：4 或 8，该值意义是指针变量指向存储地址的大小。

- 在 32 位平台，所有的指针（地址）都是 32 位(4 字节)
- 在 64 位平台，所有的指针（地址）都是 64 位(8 字节)

```c++
    char *p;
    printf("sizeof(p) = %d\n", sizeof(p));
    printf("sizeof(double *) = %d\n", sizeof(double *));
```

### 2.2 野指针和空指针

**空指针**：把 NULL 赋值给指针，表示此指针变量没有指向任何变量(空闲可用)。NULL 指针并未指向任何东西，因为对一个 NULL 指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个 NULL 指针。

```c++
    int *p = NULL;          // NULL是一个值为0的宏常量：#define NULL ((void *)0)
```

**野指针**：任意数值赋值给指针变量都没有意义（只要不越界即可，如 64 位 8 字节），因为这样的指针就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。

野指针产生条件：

- 指针在刚创建时不会成为 NULL 指针，其缺省值是随机的，这样就会产生野指针。所以建议在创建指针变量时就要初始化。
- 指针在 free 或 delete 后未赋值 NULL，此时只是释放指针所指的内存，却没有杀死指针本身。所以建议在释放指针后设置指针为 NULL。
- 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。

### 2.3 万能指针 void \*

void \*指针可以指向任意变量的内存空间：

```c
 void *p = NULL;

 int a = 10;
 p = (void *)&a; //指向变量时，最好转换为void *

 //使用指针变量指向的内存时，转换为int *
 *( (int *)p ) = 11;
 printf("a = %d\n", a);           // 11
```

### 2.4 const 修饰的指针变量

在编辑程序时，指针作为函数参数，如果不想修改指针对应内存空间的值，需要使用 const 修饰指针数据类型：

```c
 int a = 100;
 int b = 200;

    //指向常量的指针：修饰*，指针指向内存区域不能修改，指针指向可以变
 const int * p1 = &a;    // 等价于int const *p1 = &a;
 p1 = &b;                // 错误方式：*p1 = 111;

    //指针常量：修饰p1，指针指向不能变，指针指向的内存可以修改
 int * const p2 = &a;
 *p2 = 222;              // 错误方式：p2 = &b;
```

## 三 指针与数组

数组地址其实就是首元素地址：

```c++
    int arr[] = {1,2,3,4};

    // 二者值一致
    printf("%p\n", arr);
    printf("%p\n", &arr[0]);

    //a = 10; //err, 数组名只是常量，不能修改
```

如果数组的每个元素都是指针，那么该数组是指针数组。

## 四 指针与函数

### 4.1 函数形参改变实参值

```c++
#include <stdio.h>

void swap1(int x, int y){
 int tmp;
 tmp = x;
 x = y;
 y = tmp;
 printf("x = %d, y = %d\n", x, y);
}

void swap2(int *x, int *y){
 int tmp;
 tmp = *x;
 *x = *y;
 *y = tmp;
}

int main(){

    // 值传递
 int a = 3;
 int b = 5;
 swap1(a, b);
 printf("a = %d, b = %d\n", a, b);

    // 地址传递
 a = 3;
 b = 5;
 swap2(&a, &b);
 printf("a2 = %d, b2 = %d\n", a, b);

 return 0;
}
```

### 4.2 数组名做函数参数

数组名做函数参数，函数的形参会退化为指针：

```c++
#include <stdio.h>

void printArrary(int *a, int n) {
 int i = 0;
 for (i = 0; i < n; i++)
 {
  printf("%d, ", a[i]);
 }
 printf("\n");
}

int main(){
 int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
 int n = sizeof(a) / sizeof(a[0]);

 //数组名做函数参数
 printArrary(a, n);
 return 0;
}
```

#### 4.3 指针做为函数的返回值

```c
#include <stdio.h>

int a = 10;

int *getA(){
 return &a;
}


int main(){
 *( getA() ) = 111;
 printf("a = %d\n", a);

 return 0;
}
```

## 五 多级指针

C 语言允许有多级指针存在，二级指针就是指向一个一级指针变量地址的指针。

```c++
 int a = 10;
 int *p = &a; //一级指针
 *p = 100; //*p就是a

 int **q = &p;
 //*q就是p
 //**q就是a

 int ***t = &q;
 //*t就是q
 //**t就是p
 //***t就是a
```
