# 10-内存管理

## 一 作用域

### 1.1 C 语言作用域分类

- 块级作用域：`{}`之间包围的部分
- 函数级作用域：函数内包含的部分
- 文件作用域：单个 C 文件包含的部分

### 1.2 局部变量

局部变量：即 auto 自动变量，auto 可省略，一般`{}`内部的变量都是局部变量。

```c++
#include <stdio.h>

void test() {
    auto int b = 10;// auto可省略
}

int main() {
    printf(b);      // 错误，main作用域中没有b
    return 0;
}
```

### 1.3 全局变量

全局变量在函数外定义，可被本文件中的函数共用。如果添加 `extern` 声明，则也可以被其他文件中的函数调用。

贴士：`extern`只是声明，不是定义，表示这个全局变量在别的文件中已经定义了。

全局变量的生命周期和程序运行周期一样，不同文件的全局变量不可重名。

注意：在 C 中，函数默认都是全局的，也可以在其他文件使用。

### 1.3 static 静态修饰符

static 可以修饰的变量是静态变量，该变量的生命周期和程序运行周期一致，且具备以下特性：

- 静态变量的值只能被初始化一次，但可以赋值多次
- 静态修饰的变量、函数，作用域都变为文件级，且不同文件中的可以出现重名
- 静态局部变量若未赋值，则系统自动赋值：数值型赋值为 0，字符型赋值为空字符

```c++
#include <stdio.h>

void test() {
   static int a;            // 静态局部变量
   a++;
   printf("a = %d \n", a);
}

int main() {
    test();                 // 1
    test();                 // 2
    return 0;
}
```

## 二 内存布局

### 2.1 运行前分区

C 源码默认生成了二进制文件：`a.out`，可以通过一些命令查看其基本情况`size a.out`，如图所示：

![size查看结果](../images/c/10-01.png)

程序在没有运行前（即没有加载到内存前），可执行程序已经有了三段信息：

- **代码区 text**：存放 CPU 执行的机器指令
  - 通常可共享（即其他程序也可调用），共享的目的是只需要内存中保留一份即可
  - 代码区也规划了局部变量的相关信息
  - 程序在加载到内存前，代码区大小固定，运行期不能改变
- **数据区 data**：存储被初始化的全局变量，已经初始化的静态变量、常量
- **未初始化区 bss**：存入的是全局未初始化变量、未初始化静态变量，也可以将 data 和 bss 统一命名为静态区/全局区
  - 数据在程序开始执行前被内核初始化为 0 或者空 NULL
  - 程序在加载到内存前，bss 区大小固定，运行期不能改变

总体来讲说，程序源代码被编译之后主要分成两种段：程序指令(代码区)和程序数据（数据区）。代码段属于程序指令，而数据域段和.bss 段属于程序数据。程序在加载到内存前，代码区和全局区(data 和 bss)的大小就是固定的，程序运行期间不能改变。

那为什么把程序的指令和程序数据分开呢？

程序被 load 到内存中之后，可以将数据和代码分别映射到两个内存区域。由于数据区域对进程来说是可读可写的，而指令区域对程序来讲说是只读的，所以分区之后呢，可以将程序指令区域和数据区域分别设置成可读可写或只读。这样可以防止程序的指令有意或者无意被修改；
当系统中运行着多个同样的程序的时候，这些程序执行的指令都是一样的，所以只需要内存中保存一份程序的指令就可以了，只是每一个程序运行中数据不一样而已，这样可以节省大量的内存。比如说之前的 Windows Internet Explorer 7.0 运行起来之后， 它需要占用 112 844KB 的内存，它的私有部分数据有大概 15 944KB，也就是说有 96 900KB 空间是共享的，如果程序中运行了几百个这样的进程，可以想象共享的方法可以节省大量的内存。

### 2.2 运行中新增分区

程序运行中会额外增加栈区、堆区。

![栈区、堆区](../images/c/10-02.png)

- **text 代码区**：加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。
- **data 全局初始化数据区/静态数据区**：加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。
- **bss 未初始化数据区**：加载的是可执行文件 BSS 段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。
- **stack 栈区**：栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。
- **堆区**：堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于 BSS 区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。

#### 2.3 内存分区总结

| 类型            | 作用域   | 生命周期       | 存储位置                            |
| --------------- | -------- | -------------- | ----------------------------------- |
| 局部变量        | {}内     | 当前函数       | 栈区                                |
| static 局部变量 | {}内     | 整个程序运行期 | 初始化在 data 段，未初始化在 BSS 段 |
| extern 变量     | 整个程序 | 整个程序运行期 | 初始化在 data 段，未初始化在 BSS 段 |
| static 全局变量 | 当前文件 | 整个程序运行期 | 初始化在 data 段，未初始化在 BSS 段 |
| extern 函数     | 整个程序 | 整个程序运行期 | 代码区                              |
| static 函数     | 当前文件 | 整个程序运行期 | 代码区                              |
| register 变量   | {}内     | 当前函数       | 运行时存储在 CPU 寄存器             |
| 字符串常量      | 当前文件 | 整个程序运行期 | data 段                             |

总结：

- 数据区包括：堆，栈，全局/静态存储区。
- 全局/静态存储区包括：常量区，全局区、静态区。
- 常量区包括：字符串常量区、常变量区。
- 代码区：存放程序编译后的二进制代码，不可寻址区。
  可以说，C/C++内存分区其实只有两个，即代码区和数据区。

## 三 函数调用模型

### 3.1 栈

栈(stack)是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今能见到的所有计算机的语言。

在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中(入栈，push)，也可以将压入栈中的数据弹出(出栈，pop),但是栈容器必须遵循一条规则：先入栈的数据最后出栈(First In Last Out,FILO).

在经典的操作系统中，栈总是向下增长的。压栈的操作使得栈顶的地址减小，弹出操作使得栈顶地址增大。

栈保存一个函数调用所需要维护的信息，这通常被称为堆栈帧(Stack Frame)或者活动记录(Activate Record).一个函数调用过程所需要的信息一般包括以下几个方面：

- 函数的返回地址；
- 函数的参数；
- 临时变量；
- 保存的上下文：包括在函数调用前后需要保持不变的寄存器。

栈调用过程示例：

```c++
int func(int a,int b){
 int t_a = a;
 int t_b = b;
 return t_a + t_b;
}

int main(){
 int ret = 0;
 ret = func(10, 20);
 return EXIT_SUCCESS;
}
```

![栈调用](../images/c/10-03.png)

#### 3.2 调用惯例

如果函数调用方在传递参数的时候先压入 a 参数，再压入 b 参数，而被调用函数则认为先压入的是 b,后压入的是 a,那么被调用函数在使用 a,b 值时候，就会颠倒。

因此，函数的调用方和被调用方对于函数是如何调用的必须有一个明确的约定，只有双方都遵循同样的约定，函数才能够被正确的调用，这样的约定被称为”调用惯例(Calling Convention)”.一个调用惯例一般包含以下几个方面：

- 函数参数的传递顺序和方式：最常见的是通过栈传递，有些调用惯例还允许使用寄存器传递参数，以提高性能。
- 栈的维护方式：在函数将参数压入栈中之后，函数体会被调用，此后需要将被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。为了在链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。

事实上，在 c 语言里，存在着多个调用惯例，而默认的是 cdecl.任何一个没有显示指定调用惯例的函数都是默认是 cdecl 惯例。

比如 func 函数的声明，它的完整写法应该是：

```c++
 int _cdecl func(int a,int b);
```

注意: \_cdecl 不是标准的关键字，在不同的编译器里可能有不同的写法，例如 gcc 里就不存在\_cdecl 这样的关键字，而是使用**attribute**((cdecl)).

| 调用惯例 | 出栈方     | 参数传递                                       | 名字修饰                   |
| -------- | ---------- | ---------------------------------------------- | -------------------------- |
| cdecl    | 函数调用方 | 从右至左参数入栈                               | 下划线+函数名              |
| stdcall  | 函数本身   | 从右至左参数入栈                               | 下划线+函数名+@+参数字节数 |
| fastcall | 函数本身   | 前两个参数由寄存器传递，其余参数通过堆栈传递。 | @+函数名+@+参数的字节数    |
| pascal   | 函数本身   | 从左至右参数入栈                               | 较为复杂，参见相关文档     |

#### 3.3 栈的生长方向和内存存放方向

![栈的生长方向和内存存放方向](../images/c/10-04.png)

```c++
//1. 栈的生长方向
void test01(){

 int a = 10;
 int b = 20;
 int c = 30;
 int d = 40;

 printf("a = %d\n", &a);
 printf("b = %d\n", &b);
 printf("c = %d\n", &c);
 printf("d = %d\n", &d);

 //a的地址大于b的地址，故而生长方向向下
}

//2. 内存生长方向(小端模式)
void test02(){

 //高位字节 -> 地位字节
 int num = 0xaabbccdd;
 unsigned char* p = &num;

 //从首地址开始的第一个字节
 printf("%x\n",*p);
 printf("%x\n", *(p + 1));
 printf("%x\n", *(p + 2));
 printf("%x\n", *(p + 3));
}s
```

## 四 内存操作函数

### 4.1 memset()

```c++
/*
void *memset(void *s, int c, size_t n);
功能：将s的内存区域的前n个字节以参数c填入
参数：s：需要操作内存s的首地址
     c：填充的字符，c虽然参数为int，但必须是unsigned char , 范围为0~255
     n：指定需要设置的大小
返回值：s的首地址
*/
#include <stdio.h>
#include <string.h>

int main(){
  int a[10];
  memset(a, 0, sizeof(a));
  memset(a, 97, sizeof(a));
  int i = 0;
  for (i = 0; i < 10; i++){
    printf("%c\n", a[i]);
  }

  return 0;
}
```

### 4.2 memcpy()

```c++
/*
void *memcpy(void *dest, const void *src, size_t n);
功能：拷贝src所指的内存内容的前n个字节到dest所值的内存地址上。
参数：
 dest：目的内存首地址
 src：源内存首地址，注意：dest和src所指的内存空间不可重叠，可能会导致程序报错
 n：需要拷贝的字节数
返回值：dest的首地址
*/
#include <stdio.h>
#include <string.h>

int main(){
 int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
 int b[10];

 memcpy(b, a, sizeof(a));
 int i = 0;
 for (i = 0; i < 10; i++){
  printf("%d, ", b[i]);
 }
 printf("\n");

 //memcpy(&a[3], a, 5 * sizeof(int)); //err, 内存重叠

 return 0;
}
```

### 4.3 memmove()

memmove()功能用法和 memcpy()一样，区别在于：dest 和 src 所指的内存空间重叠时，memmove()仍然能处理，不过执行效率比 memcpy()低些。

### 4.4 memcmp()

```c++
/*
int memcmp(const void *s1, const void *s2, size_t n);
功能：比较s1和s2所指向内存区域的前n个字节
参数：
 s1：内存首地址1
 s2：内存首地址2
 n：需比较的前n个字节
返回值：
 相等：=0
 大于：>0
 小于：<0
*/
#include <stdio.h>
#include <string.h>

int main(){
  int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
  int b[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

  int flag = memcmp(a, b, sizeof(a));
  printf("flag = %d\n", flag);
  return 0;
}

```

### 4.5 堆区内存分配 malloc()

```c++
/*
void *malloc(size_t size);
功能：在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域，用来存放类型说明符指定的类型。分配的内存空间内容不确定，一般使用memset初始化。
参数：
 size：需要分配内存大小(单位：字节)
返回值：
成功：分配空间的起始地址
失败：NULL
*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main(){
 int count, *array, n;
 printf("请输入要申请数组的个数:\n");
 scanf("%d", &n);

 array = (int *)malloc(n * sizeof (int));
 if (array == NULL)
 {
  printf("申请空间失败!\n");
  return -1;
 }
 //将申请到空间清0
 memset(array, 0, sizeof(int)*n);

 for (count = 0; count < n; count++) /*给数组赋值*/
  array[count] = count;

 for (count = 0; count < n; count++) /*打印数组元素*/
  printf("%2d", array[count]);

 free(array);

 return 0;
}
```

### 4.6 堆区内存释放 free()

```c++
/*
void free(void *ptr);
功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。对同一内存空间多次释放会出错。
参数：
ptr：需要释放空间的首地址，被释放区应是由malloc函数所分配的区域。
返回值：无
*/
#include <stdlib.h>

```

## 五 获取各区地址

栈区地址：

```c++
#include <stdio.h>
int *fun(){
 int a = 10;
 return &a;//函数调用完毕，a释放
}

int main(int argc, char *argv[]){
 int *p = NULL;
 p = fun();
 *p = 100; //操作野指针指向的内存,err

 return 0;
}
```

data 区地址：

```c++
#include <stdio.h>

int *fun(){
 static int a = 10;
 return &a; //函数调用完毕，a不释放
}

int main(int argc, char *argv[]){
 int *p = NULL;
 p = fun();
 *p = 100; //ok
 printf("*p = %d\n", *p);

 return 0;
}
```

值传递情况一：

```c++
#include <stdio.h>
#include <stdlib.h>

void fun(int *tmp){
 tmp = (int *)malloc(sizeof(int));
 *tmp = 100;
}

int main(int argc, char *argv[]){
 int *p = NULL;
 fun(p); //值传递，形参修改不会影响实参
 printf("*p = %d\n", *p);//err，操作空指针指向的内存

 return 0;
}
```

值传递情况二：

```c++
#include <stdio.h>
#include <stdlib.h>

void fun(int *tmp){
 *tmp = 100;
}

int main(int argc, char *argv[]){
 int *p = NULL;
 p = (int *)malloc(sizeof(int));

 fun(p); //值传递
 printf("*p = %d\n", *p); //ok，*p为100

 return 0;
}
```

堆区地址：

```c++
#include <stdio.h>
#include <stdlib.h>

int *fun()
{
 int *tmp = NULL;
 tmp = (int *)malloc(sizeof(int));
 *tmp = 100;
 return tmp;//返回堆区地址，函数调用完毕，不释放
}

int main(int argc, char *argv[])
{
 int *p = NULL;
 p = fun();
 printf("*p = %d\n", *p);//ok

 //堆区空间，使用完毕，手动释放
 if (p != NULL)
 {
  free(p);
  p = NULL;
 }

 return 0;
}
```
