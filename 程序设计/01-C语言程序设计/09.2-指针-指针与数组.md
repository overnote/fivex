# 09.2-指针-指针与数组

## 一 数组指针

### 1.1 一维数组指针

数组地址其实就是首元素地址：

```c++
    int arr[] = {1, 2, 3, 4};
    int *p = &arr[0];

    // 三者值一致
    printf("%p, %p\n", p, arr);
```

指针类型与数组类型在大多数场合都可以互换使用，但是他们仍然是不同的类型，主要区别有三点：

- 1、数组是一片连续的存储空间，在定义的时候已经为所有的数组元素分配了位置，而指针只是一个保存数据地址的存储单元，未经正确赋值之前不指向任何合法的存储空间，因此不能通过它进行任何数据访问。此时赋值会产生野指针。
- 2、通过数组所能访问的数据的数量（元素个数）在数组定义时就已经确定，而指针所能访问的数据的数量取决于指针所指向的存储空间的性质和规模。
- 3、数组名是一个常量而不是一个变量，不能被赋值。

数组指针类型：

```c
    int (*p)[5] = (int(*)[5])malloc(sizeof(int) * 5);
```

在 C 程序中经常利用指针与数组的可互换性来支持数组的负数下标，语法上不合法，但是如果一个指针指向数组中间的某个元素，则可以将改数组作为一个可以支持负数下标的数组来使用：

```c
/**
 * 从标准输入上读入两行由不超过100位数组构成的字符串，计算2个字符串表示的正整数和
 * 解析：
 * 常规计算机无法处理超过20位的整数，超长数值运算也称为高精度运算。
 * 一般需要将数据逆序读入为字符数组，按位操作，最后再逆序输出字符串化的结果。
 * 数据的最高位对应数组下标为0，数组下标随着数位权重递减而递增，所以可以使负数下标。
 */
#include <stdio.h>
#include <string.h>

char a[N], b[N];// N 需要大于所需处理的最大数的长度

int main(){
    // 用于计算的数字字符串p和q
    char *p, *q, *t;
    int i, len_p, len_q, tmp;
    // PAD 是大于等于1的整数，说明在读入数字串前端保留用于加法进位的数组元素数量
    p = &a[PAD];
    q = &b[PAD];
    scanf("%s%s", p, q);
    len_p = strlen(p);
    len_q = strlen(q);

    // 使指针指向字符串的末尾
    if(len_p >= len_q){
        p += len_p - 1;
        q += len_q - 1;
    } else {
        t = q;
        q = p + len_p - 1;
        p = t + len_q - 1;
        tmp = len_q;
        len_p = len_q;
        len_q = tmp;
    }

    for (i = 0; i > -len_q; i--){
        p[i] += q[i] - '0';
    }

    for (i = 0; i > -len_p; i--){
        if((p[i] - '0') >= 10){
            p[i - 1] += (p[i] - '0') / 10;
            p[i] = (p[i] - '0') % 10  + '0';
        }
    }

    if(p[i] != 0){
        p[i] += '0';
    }else {
        i++
    }

    printf("%s\n", &p[i]);

    return 0;
}
```

### 1.2 指向二维数组的指针

指向二维数组的指针，其指向的数据实体是二维数组中的一行元素，即一个一维数组，其包含的元素个数等于二维数组的列数。所以定义一个二维数组需要指明其列数，而与其行数没有关系：

```c
double arr1[32][64], arr2[64][128], arr3[16][128];
double (*ap)[64], (*bp)[128], (*cp)[128];

// ap指针指向了arr1中下标为0的行，此时ap和arr1等价
ap = arr1;
// 此外：*ap、ap[0]等价于arr1[0], (*ap)[3]、*(*ap + 3)、ap[0][3]都等价于 arr1[0][3]

// bp可以指向arr2,arr3，或者数组中的任意一行，因为这2个数组的元素类型以及列数与bp定义相同
bp = arr2;
bp = &arr3[5];
// 此外：bp等价于从arr3[5]开始的二维数组：*bp、bp[0]等价于arr3[5]，(*bp)[3]、*(*bp + 3)、bp[0][3]等价于arr3[5][3]

cp = &arr3[8];
```

与一维数组指针类似，二维数组指针加减一个整数 n 就等于指向原来位置后面或者前面第 n 行，示例中 `ap--`、`--bp` 其实会分别使 ap 和 bp 指向前一行。

当指向同一数组的二维指针相减时，若结果是一个整数，表示 2 个指针所指向的内容相差的行数。比如示例中 bp 指向 arr3 的第五行，cp 指向 arr3 下标为 8 的行，所以`cp-bp=3`。

与一维数组类似，二维数组作为函数参数也可以声明为指针类型：

```c
// 二者等价
void arr_add(int t1[][5], int t2[][5], int s[][5]);
void arr_add(int (*t1)[5], int (*t2)[5], int *(s)[][5]);
```

## 二 指针数组

元素类型为指针的数组即为指针数组。指针数组定义时需要在类型和数组名之间加上 `*` 号：

```c
int *p[100];

// 也可以在定义时初始化：但此时指针数组初始化表中只能包含变量的地址、数组名、无效指针的常量NULL
double d1[100], d2[200], d3[300], avg, sum;
double *dp[] = {d1, d2, d3, &avg, &sum, NULL};  // 6个double类型的指针数组
```

示例：

```c
/**
 * 使用指针数组设计函数 week_day()，已经某月x日是星期y，该月有n天，该函数输出下一个月k日是星期几
 */
char *week_days[] = {
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
}

void week_day(int x, int y, int n, int k){
    int m;
    m = (n - x + y + k) % 7;
    printf("%s\n", week_days[m]);
}
```

指针数组与二维数组区别：

- 1、指针数组中只为指针分配了存储空间，其指向的数据元素所需要的存储空间是通过其他方式分配的
- 2、二维数组每一行中元素的个数是在数组定义时明确规定的，并且是完全相同的，而指针数组中各个指针所指向的存储空间的长度不一定相同
- 3、二维数组中全部元素的存储空间是连续排列的，而指针数组中只有各个指针的存储空间是连续排列的，指针所指向的数据元素的存储排列顺序取决于存储空间的分配方法。

指针数组经常用于复杂程序中，用来作为各种数据的索引，以便有效的组织数据、简化程序、提升运行速度。比如要对二维数组进行排序时，如果字符串 A 和字符串 B 需要进行交换顺序，那么需要字符串 A 复制到一个临时缓冲区，然后把 B 复制到 A 原来的位置上，最后从缓冲区取将 A 的字符串复制到 B 上。如果字符串长度较长，交换次数较多，则操作效率会变低，如果利用指针数组作为索引对字符串数组进行排序，则只需要交换着两行所对应的指针即可。
