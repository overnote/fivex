# 07.2-数组-基于数组的数据结构

使用数组可以实现一些高级数据结构，如：哈希表、栈、队列。

## 一 哈希表

### 1.1 哈希表概念

哈希表（hash table）也称为散列表，该数据结构可以键值，直接确定是护具在存储结构中的位置。当以数组实现哈希表时，需要使用映射函数把键值转换为数组下标，以便数据的定位。

一些时候，一些 int 型的数据也被直接作为数组下标用于相关数据的定位，也就是说：映射函数的取值就是函数的自变量。这类哈希表也被称为索引表、映射表，除了用于数据查找外，还可以用于数据的关联。

### 1.2 示例一：区间合并

在标准输入上读入 n(n <= 100000) 个闭区间$[a_i,b_i]$$(1 <= a_i < b_i <= 10^6$且均为正数)，将这些区间合并为不相交的闭区间，例如 [1, 2]、[2, 5]、[3, 8]、[9, 12] 合并为[1, 8],[9, 12]。写一个程序，每行包含两个由空格分割的整数 $a_i$ 和 $b_i$，表示区间[$a_i, b_i$]，输出该结果，并将计算结果写在标准输出上。

上述问题，选择不同的数据结构有不同的复杂度，由于题目中的值并不大，可以使用一维数组构成的哈希表作为存储结构。以区间下界 $a_i$ 作为键值直接映射为数组的下标，将区域的上届 $b_i$ 保存在在下标为 $a_i$ 的数组元素中，构成映射关系，合并后的输出可以判断该位置是否有元素，有则判断输出。

```c
#include <stdio.h>

#define MAX_N (1024 * 1024)
int range[MAX_N];

void print_zone(){
    int i, n;
    for (i = 0; i < MAX_N; i++){
        if(range[i] == 0){
            continue;
        }
        printf("%d ", i);
        for (n = range[i]; i <= n; i++){
            if(range[i] > n){
                n = range[i];
            }
        }
        i--;
        printf("%d\n", i);
    }
}

int main(){
    int a, b;
    while (scanf("%d%d", &a, &b) == 2){
        if (b > range[a]){
            range[a] = b;
        }
        print_zone();
    }

    return 0;
}
```

### 1.3 示例二 生成质数表

质数的生成可以通过试除法：逐一检查质数范围内的每个数四否能被其他数整除。当最大数 n 较大时，该做法效率太低，可以采取筛选法：首先把 n 以下的自然数放入一个一维数组中，然后首先删除 2 的倍数，然后再删除剩余数中最小数的倍数，如此反复，直到无数可删为止：

```c
void gen_primes(char *primes, int N){
    int i, j, step;
    memset(primes, 1, N);
    primes[0] = primes[1] = 0;
    for (i = 2; i * i < N; i++) {
        if(!primes[i]){
            continue;
        }
        step = i;
        for (j = i + i; j < N; j += step)
        {
            primes[j] = 0;
        }
    }
}
```

## 二 栈

### 2.1 栈概念

栈遵循后劲先出的规则，即最后被保存的数据会被首先取出。在程序执行过程中，函数的调用和返回序列就保存在栈中。

栈的常见操作有：初始化、压栈、弹栈、检测栈是否为空。在一般的设计中，栈顶的位置初始值为 0，初始时指向数组的第一个元素。

常见操作如下：

```c
void push(int v){
    statck[s_top++] = v;
}

int pop(){
    return statck[--s_top];
}

int stack_empty(){
    return s_top == 0
}
```

### 2.2 示例一 括号匹配

检查一个由方括号和圆括号组成的参数字符串中的括号是否匹配正确。当正确时返回符号常量 OK，否则返回 ERR，例如 `[]()[]`、`[([()]())[]()]`都是括号能匹配正确的，而 `[()[]]`、`[([(])())[]()]` 都是不正确的例子。

括号序列正确的匹配的判断条件是：每一个左括号必须右一个与之匹配的右括号，即：左括号与右括号的数量必须相等，并且左括号与其所匹配的右括号必须在同一层，其间不能包含有未匹配的其他类型的括号。因此，验证可以分为两步骤：

- 顺序扫描括号序列遇到右括号时，检验是否存在与其匹配的左括号，以及这一对括号之间是否有其他类型的未匹配括号
- 完成了对输入括号序列的扫描后，检验是否有左括号都有与之正确匹配的右括号。

检验算法可以实践为以下步骤：

- 1、逐个读入输入的字符，直到输入结束，转向 6
- 2、当遇到左括号时将其入栈
- 3、当遇到右括号时，检查当前栈顶的元素
- 4、如果栈顶元素与其匹配，则转向 1
- 5、如果栈顶元素与其不匹配，或者栈为空，则输出 ERR，结束匹配过程
- 6、结束匹配过程，检查栈是否为空，如果栈为空，则输出 OK，否则输出 ERR

```c
int paran_match(char *s){
    char *p;
    int d;

    for(p = s; *p != '\0'; p++){
        if(*p == '(' || *p == '['){
            push(*p);
        } else if(*p == ')' || *p == ']'){
            if(stack_empty()){
                return ERR;
            }
            d = pop();
            if( ((*p == ')' && d == '(')) || ((*p == ']' && d == '['))){
                continue;
            }
            return ERR;
        }
    }
    return stack_empty() ? OK : ERR;
}
```

## 三 队列

### 3.1 队列概念

队列是遵循先进先出的线性数据结构，即从一端存入，从一端取出。数据从队列中取出的顺序与其进入队列的顺序相同。

队列的常见操作是：初始化、入队（从队尾写入数据）、出队（从队头取出数据）、检查队列是否为空、检查队列是否已满。

队列的初始化工作包括为队列分配存储空间，说明队头和队尾的位置，即需要定义 2 个变量，分别表示队头元素和队尾元素，如下所示：

```c
int queue[Q_N], head = 0; tail = 0;

void put(int v){
    queue[tail++] = v;
}

int get(){
    return queue[head++];
}
```

### 3.2 示例 N 位超级质数

从标注输入读入一个整数 N(N<9)，生成所有满足下列条件的 N 位超级质数：左侧前任意连续位均是质数。例如：23，233，2339，23399 的 2 位、3 位、4 位、5 位超级质数。

简单的求解方法是：遍历所有的 N 位正整数，并逐一检查每一个数的前一位、后前两位等等是否构成质数。但是该方法效率低，N 比较大时计算速度很慢。

首先以所有的一位质数作为种子集合，然后在每个种子后面增加一个数字，并且检查新生成的两位数是否是质数。如果新生成的两位数仍然是质数，就把它放进种子集合种。重复这一过程，就可以从种子集合中生成所有长度为 N 的质数。

```c
#define NumOf(a) (sizeof(a) / sizeof(a[0]))

int hd = 0, tail = 4, queue[MAX_Q] = [2,3,5,7]; // 初始queue只包含一位质数
int digits[] = {1,3,7,9};   // 可用于n-1位的数字表

int main(){
    int i,m,n,ken,end = 0;  // end的初始值用于当 n == 1 因而循环语句不执行时

    scanf("%d", &n);

    for(len - 1; len < n; len++){
        for(end = tail; hd < end; hd++){
            m = queue[hd] * 10;
            for(i = 0; i < NumOf(digits); i++){
                if(isPrime(m + digits[i])){
                    queue[tail++] = m + digits[i];  // 生成并存储比种子长一位的质数
                }
            }
        }
    }

    for(i = end; i < tail; i++){
        printf("%d\n", queue[i]);
    }
    return 0;
}
```
