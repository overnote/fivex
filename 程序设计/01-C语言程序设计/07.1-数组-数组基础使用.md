# 07.1-数组-数组基础使用

## 一 数组概述

数组就是在内存中连续的相同类型的变量空间：

- 各个数据的排列有一定的规律，下标代表数据在数组中的序号
- 数组中每个元素都属于同一个数据类型，不能把不同类型的数据放在同一个数组中

通常情况下，数组元素下标的个数也称为维数，根据维数的不同，可将数组分为一维数组、二维数组、三维数组、四维数组等。通常情况下，我们将二维及以上的数组称为多维数组。

## 二 数组的使用

### 2.1 数组定义

数组的定义：

```c++
int a[10];  // 数组名为 a ，下标从0开始，最大索引为 9
int b[3+5]; // 该定义方式合法
```

不合法的定义：

```c++
int n;
int a[n]; // C语言不允许对数组的大小做动态定义
```

在非主函数的函数中，数组长度可以是变量或者非常量表达式：

```c++
void fn(int n) {
    int a[2 * n];  // 这是一个可变长数组，注意不能使用static修饰
}
```

### 2.2 数组初始化

```c++
int a[5] = {0};     // 未赋值部分自动设为0
int b[5] = {0,1};   // 只给一部分赋值，没赋值的默认为0
int c[5] = {0,1,2,3,4}
int c[] = {0,1,2,3,4,5} // 给全部元素赋值时，可以不指定数组长度，此时长度已经是5了
```

### 2.3 数组越界

编译系统不会对数组元素的下标进行越界检查，因为这不属于语法错误！因此，在编译时不会报告越界错误，而在运行时才会产生错误！

### 2.4 获取数组元素数量

使用下面的表达式可以获取数组长度：

```c
    int arr[] = {1, 2, 3, 4, 5};
    // 数组总size 除以 单个元素的size
    printf("%lu\n", sizeof(arr) / sizeof(arr[0]));  // 5
```

数组元素个数的使用非常广泛，可以使用宏定义一个通用规则：

```c
#include <stdio.h>

#define Len(arr) (sizeof(arr) / sizeof(arr[0]))

int main(){
    int arr[] = {1, 2, 3, 4, 5};
    printf("%lu\n", Len(arr));  // 5
}
```

### 2.5 数组遍历

```c
for(i = 0; i < Len(arr); i++){}
```

### 2.6 数组复制

由于数组不是普通变量，数组复制不能简单的使用相等符号。有以下两种复制方式：

```c
// 长度为正整数 N 的 double 类型数组  arr1[], arr2[] ，arr1[] 的元素都被赋值了，现在要拷贝到 arr2[]

// 方式一
for(int i = 0; i < N; i++){
    arr2[i] = arr1[i];
}

// 方式二：数组是一片连续的存储空间，可以将指定数量的字节复制到目的地地址
memcpy(arr2, arr1, sizeof(arr1));
// 或者
memcpy(arr2, arr1, sizeof(double) * N);
```

### 2.7 数组作为函数参数

当数组作为参数时，形参列表中的数组一般不会书写数组元素个数，当然提供了数字的元素个数也不是错误的，只不过意义不大，函数内部是不知道数组的大小的。

判断数组在函数中的大小，可以采用下列三种方式

- 事先约定固定值
- 函数新设一个参数，用以说明数组长度
- 数组末尾添加一个非正常函数值，比如正整数数组，末尾添加一个负数，当循环到该负数时，则表示循环结束，即可判断大小

注意：数组作为函数参数，在函数内发生改变后，数组的实参（原始值）是会发生改变的。这是因为实际参数数组中的元素是被函数及调用者共享的。**参数数组**的这种特点是由数组元素的访问方式引起的，数组作为参数的时候仍然是先被求值再传递给函数的，这里的求值本质是得到了数组的地址！

贴士：数组的地址其实是其首元素的地址。

```c
#include <stdio.h>

int arr[] = {1, 2, 3, 4, 5};

void fn(int arr[]){
    arr[0] = 5;
}

int main(){
    fn(arr);
    printf("%d\n",arr[0]);  // 5
}
```

## 三 数组的排序与查找

### 3.1 数组排序

选择排序（selection sort）是常用的排序方法之一。假如现在要进行升序排列数组，选择排序的做法是：

- 首先在所有元素中找到最小元素，将其放在数组首位
- 接着在剩余元素中找到最小元素，并将其放在数组第二位
- 依次类推 ，直到数组中只剩下一个元素为止

同理：查找最大元素并替换的方式也是一样的。

```c
#include <stdio.h>

int arr[] = {3, 2, 4, 5, 1};

void sel_sort(int arr[], int N){
    int i, j, min, index; // min 为某轮循环找到的最小值
    for (i = 0; i < N - 1; i++){
        min = arr[i], index = i;
        // 循环剩余元素
        for (j = i + 1; j < N; j++){
            if(arr[j] < min){
                min = arr[j], index = j;
            }
        }
        if(index != i){
            arr[index] = arr[i], arr[i] = min;
        }
    }
}

int main(){
    sel_sort(arr, 5);
    for(int i = 0; i < 5; i++){
         printf("%d\n",arr[i]);
    }

}
```

### 3.2 数组查找

二分查找法是效率较高的查找方法，其前提是数组必须是排好序的。操作步骤如下：

首先将待查数值与位于数组中间的的元素进行比较，如果数组中间元素的值等于待查数值，则可以立即结束查找，返回该元素的位置。否则，会根据待查数值是小于还是大于中间元素的值，分别在数组的前半部分或后半部分再次进行二分查找，直到找到与待查素质相等的数组元素，或者查找区间为空为止。

从上看出，二分查找每次开始一轮比较时，至少可以排除待查区间中一半的数据。设数组有 n 个元素，数组中的待查元素就只剩下$n/2^k$，所以使用二分查找法，最多只需要进行$(log_2n + 1)$次比较。

```c
#include <stdio.h>

int arr[] = {1, 2, 3, 4, 5};

int binsearch_r(int v, int arr[], int low, int hig){
    int mid;
    if(low > hig){
        return -1;
    }
    mid = (low + hig) / 2;
    if(v == arr[mid]){
        return mid;
    } else if(v > arr[mid]){
        return binsearch_r(v, arr, mid + 1, hig);
    } else {
        return binsearch_r(v, arr, low, mid - 1);
    }
}

int binsearch(int v, int arr[], int N) {
    int low = 0, hig = N - 1, mid;
    while(low <= hig){
        mid = (low + hig) / 2;
        if(v < arr[mid]){
            hig = mid - 1;
        } else if(v > arr[mid]){
            low = mid + 1;
        }else {
            return mid;
        }
    }
    return -1;
}

int main(){
    printf("%d\n",binsearch(3, arr, 5));
}
```
