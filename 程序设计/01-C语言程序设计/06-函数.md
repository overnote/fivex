# 06-函数

## 一 函数概述

### 1.1 函数的分类

函数是 C 程序的基本模块，是用于完成特定任务的程序代码单元，从函数定义的角度看，函数可分为系统函数和用户定义函数两种：

- 系统函数：即库函数，由编译系统提供的，可以直接使用它们，如`printf()`，引入方式`#include <库名>`
- 自定义函数：开发者自定义的函数，引入方式`#include "文件路径名"`

### 1.2 函数的声明与调用

函数被调用时，编译系统必须知道函数的原型（函数名、参数列表、返回值类型），以便对函数实际参数、返回值的类型进行检查和必要的转换。

被调函数位于当前函数之前，可以直接调用，因为此时函数的原型已经被说明：

```c++
#include <stdio.h>

void myprint() {
    printf("hhh\n");
}

int main() {
    myprint();
    return 0;
}
```

被调函数位于当前函数之后，需要先声明再调用：

```c++
#include <stdio.h>

int main() {
    void myprint();         // 声明
    myprint();              // 调用
    return 0;
}

void myprint() {
    printf("hhh\n");
}
```

函数的声明和函数的定义首行（称为函数原型：function prototype）是基本一样的（有没有分号的区别）。其中函数声明中的形参具体名可省略不写。

声明（declaration）的作用是把函数名、参数列表、返回值类型等信息通知编译系统，以便遇到函数调用时，编译系统能够正确识别函数并检查调用是否合法。

贴士：一般来说，函数的原型保存在头文件中，该文件以 `.h` 为后缀。

## 二 局部变量与全局变量

### 2.1 局部变量

> 局部变量：定义在函数内部的变量，也称为自动变量

局部变量隶属其函数，只在函数体内部有效，只存在于函数的运行期间（所以称为自动变量）。一般需要将所有的局部变量集中定义在函数体的第一个执行语句之前，以下是一个错误示例：

```c
int x;
scanf("%d", &x);
double y;       // 报错，需要将 y 的定义移动到scanf函数的前面
```

### 2.2 全局变量

> 全局变量：定义在函数外部的变量，也称为外部变量

全局变量可以定义在所有函数之外的任何地方，不属于任何函数，在程序运行期间始终有效。

一般推荐将全局变量定义在程序的开始部分，以便集中管理。

贴士：全局变量中，如果是实型的，则其初始化值均为 0，这与局部变量不同。

### 2.3 extern 关键字

当全局变量分散在各处时，如果某个函数需要使用在其后面或者其他源文件中定义的全局变量，就需要使用变量声明语句说明该变量的类型，如下所示：

```c
#include <stdio.h>

extern int a;

void fn(){
    a += 1;
}
int a = 3;


int main(){
    fn();
    printf("%d\n", a);
}
```

### 2.4 参数传递

C 语言中，函数的参数都是值传递的。即：在运行函数调用时，程序首先对各个参数表达式进行求值操作，并将求值结果作为实际参数传递给函数。

使用值传递可以使任何符合类型要求的表达式都可以作为实际参数，而且隔离了函数内对实际参数变量的影响。也可以这样理解：函数内部，形式参数类似一个局部变量，只不过在函数运行时被赋予了初始值。所以：**在函数内部对形式参数的值如何改变都不会影响函数外部的传递给他的变量**，如下所示：

```c
#include <stdio.h>

int a = 3;

void fn(int sum){
    sum += 1;
}

int main(){
    fn(a);
    printf("%d\n", a);
}
```

### 2.5 const 修饰符

const 修饰符说明了数据是只读的，只能在初始化的时候赋值。

当限定函数时，const 一般用于指针类型：由 const 限定的指针类型参数表示在函数内部禁止通过该参数对指针指向内容进行修改。

## 三 递归调用

### 3.0 递归定义

调用一个函数的过程中，再次调用了函数本身，即为递归调用。递归调用必须可以终止，只能出现有限次数，否则会出现内存溢出情况。

递归桉树有两部分组成：

- 递归的终止条件和基础计算，当递归参数满足特定条件时进行计算并返回计算结果
- 对函数自身的递归调用，以及可能需要对递归调用结果的相关处理

贴士：很多问题既有递归的求解方式，也有非递归的求解方式。

### 3.1 示例一：最大公约数

对于两个整数 a 和 b，如果 b=0，则 a 就是 a 和 b 的最大公约数，否则 a 模 b 与 b 的最大公约数即使 a 与 b 的最大公约数。使用该方式是一种递归的定义：

```c
int gcd(int a, int b){
    if(b == 0){
        return a;
    }
    return gcd(b, a % b);
}
```

### 3.2 示例二：组合数

从 m 个不同的元素中任意取出 n 个元素组成一组称为组合，这样的组合种数记为 $C$，根据组合的定义可以得到公式：

$C{_m^1} = m$
$C{_m^m} = 1$
$C{_m^n} = C{_{m-1}^n} + C{_{m-1}^{n-1}}$

第三个式子中二者之和，也可以称为一种递归定义:

```c
int comb_num(int m, int n){
    if(m < n || m < 1 || n < 1){
        return 0;
    }
    if(n == 1){
        return m;
    }
    return comb_num(m - 1, n) + comb_num(m - 1, n - 1);
}
```

### 3.3 示例三：汉诺塔问题

示例-递归解决汉诺塔问题（Hanoi）：

```c++
/*
 * 梵塔内有3个座位：A,B,C，A座上有64个大小不等的盘子，小的在上，大的在上
 * 和尚想把这64个盘子从A座移动到C座，每次只能移动一个盘子，移动过程中，3个座位上都只能保持大盘在下，小盘在上
 * 编程输出移动盘子的步骤。

 * 解题思路：
 * 假如有第二个和尚，命令第二个和尚将63个盘子移动到B座
 * 自己讲第64个盘子（最大的那个）移动到C座
 * 命令第二个和尚将63个盘子从B座移动到C座
*/
#include <stdio.h>

void move(int n, int from, int to){
    printf("move disc %d from %c to %c\n", n, from , to);
}

void hanoi(int n, int from, int via, int to){
    if(n == 1){
        move(n, from, to);
        return;
    }
    hanoi(n - 1, from, to, via);
    move(n, from, to);
    hanoi(n - 1, via, from, to);
}

int main() {
    hanoi(46, 'A', 'B', 'C');
}
```
