# 09.1-指针-指针基础

## 一 指针的概念

### 1.1 指针定义

数据实体的地址指向其所在的内存空间，可以称为指针。通过变量名可以直接对数据实体进行读写操作，通过指针，即实体的地址也可以进行读写操作。

C 语言使用 `*` 声明指针类型的变量，使用 `&` 获取数据实体地址，例如变量 a 的地址获取方式是：`&a`，数组元素 arr[2]的地址为 `&arr[2]`。

```c++
    int a = 0;
    printf("%p \n",&a);  // &a 查看a的地址

    // 定义：int * 是指针类型，p 是指针变量名
    int *p = &a;        // 将a的地址赋值给p，没有值可以设置为 NULL

    // 读取：*p 这里的*的作用是取值，
    // 类似数组的 [索引]，在定义的时候[]是标记是数组，取值用[下标]
    printf("%d \n",*p);   // p指向了a的地址，*p就是a的值

    // 修改：指针指向的数据
    *p = 100;
    printf("%d \n",*p); // 100

    // 取值的地址：
    printf("%p, %p, %p\n", p, &*p, &a);  // 地址一样

    // &p取的是p变量本身的地址
```

指针使用贴士：

- 声明指针时，`*` 表示所声明的变量为指针类型
- 使用指针时，`*` 表示操作指针所指向的内存空间

指针所表示的是存储地址，而非数据本身，使用符号 `*` 后才能获取到数据：

```c
    int d, e = 8;
    d = *&e;
    *&e = 10;
```

上述 2 个赋值语句分别等价于 d = e 和 e = 10。

### 1.2 内存地址表现

指针主要有两个重要属性：

- 指针指向哪个数据实体
- 指针具有什么样的数据类型

一个合法的具有指针类型的数据必须指向一个完整的数据实体，如：变量、数组、数组元素、函数等。对于单位长度为多字节的数据实体，如 int 或 double 类型的变量，其地址是其第一个字节的地址！

例：

```c
    double a, b;
    int i;
    short x, y;
    unsigned int arr[6];
    char s[8];
```

上述变量在内存中的地址表现如下所示：

![内存地址](../../images/c/09-01.svg)

在上图中，在分割线上的地址都是合法指针，如：0x1230,0x1238,0x1240,0x1246,0x125c,0x1261 等，分别是 a,b,i,y,arr[5],s[1]的地址，而 0x123c 和 0x1256 则是不合法的指针。

### 1.3 总结

指针是一种数据类型，其实质就是内存地址。在开发中如果要使用一些数据的内存地址，需要用一个变量来保存该地址，这个变量称为指针变量。

对于函数来说，函数名本身就是该函数入口代码在内存中的地址，是一种具有指针类型的数据，因此无需使用&获取，同理数组名本身是该数组第一个元素的地址，因此一般情况下对数组也不使用运算符&。

## 二 指针运算

### 2.1 指针与整数加减

指向数组元素的指针与整数之间的加减可以移动指针：

```c++
    int arr[5] = {0, 1, 2, 3, 4};
    int *p = &arr[1];

    // 加n：指向当前位置后面第 n 个元素
    p = p + 2;
    printf("arr[3]的地址: %p\n", &arr[3]);
    printf("p + 2 的地址: %p\n", p);
    printf("p + 2 的元素: %d\n", *p);

    // 减n：指向前面第 n 个元素
    p = p - 3;
    printf("arr[0]的地址: %p\n", &arr[0]);
    printf("p - 3 的地址: %p\n", p);
    printf("p - 3 的元素: %d\n", *p);
```

### 2.2 指针相减

指向同一数组中元素的指针之间可以进行相减操作，得到的结果是一个 int 型的整数，表示这两个指针所指向元素之间下标之差：

```c
    int arr[] = {0, 1, 2, 3, 4, 5};
    int *p1 = &arr[1], *p2 = &arr[5];

    // 指针相减：结果为下标之差
    printf("p2 - p1: %ld\n", p2 - p1); // 4
    printf("p1 - p2: %ld\n", p1 - p2); // -4
```

### 2.3 运算符结合

C 语言规定 `*` 和后置的 `++`、`--` 一起出现时，需要从右向左结合。所以 `*p++`与`*(p++)`等价，表示++作用域指针变量 p，而`(*p)++` 表示++作用域变量 p 所指向的变量。

### 2.4 指针的比较

2 个指针间比较是否相等：可以判断是否指向同一个元素。

指针与 0 比较是否相等：可以用来判断指针是否有效，C 语言头文件中定义了一个等于 0 的符号常量 NULL。

示例 1：从标准输入上读入 N（`0<N<1000000`）行数据，每行含有 n 个由空白符分隔的实数。在标准输出上输出每个输入行的行号、数据的数量以及该行数据平均值，每行输入数据对应一个输出行，行号与数据数量之间以冒号分隔，数据数量与数据平均值之间以空格符分隔。

```c
char *get_value(char *s, double *d){
    while(*s != '\0' && isspace(*s)){
        s++;
    }
    if(sscanf(s, "%lf", d) != 1){
        return NULL;
    }
    while(*s != '\0' && !isspace(*s)){
        s++;
    }
    return s;
}

int main(){
    int i, n;
    double d, subsum;
    char buf[BUFSIZ], *p;

    for(i = 1; fgets(buf, BUFSIZ, stdin) != NULL; i++){
        subsum = 0;
        for(n = 0; p = buf; (p = get_value(p, &d)) != NULL; n++){
            subsum += d;
        }
        if(n > 0){
            prinft("%d:%d %f\n", i, n, subsum / n);
        }
    }

    return 0;
}
```

示例 2：从标准输入上读入以空格分隔的字符串 s 和 t，将 s 中首次与 t 匹配的子串逆置后再输出 s，当 s 中无与 t 匹配的子串时直接输出 s。例如：当 s 和 t 分别为 helloworld 和 wor 时，输出 hellorowld。

```c
void rev(char* first char* last){
    int tmp;
    while(first < last){
        tmp = *last;
        *last = *first;
        *first = tmp;
        first++, last--;
    }
}

int main(){
    char str[BUFSIZ], substr[BUFSIZ], *p;

    scanf("%s%s", str, substr);
    if((p = strstr(str, substr)) != NULL){
        rev(p, p + strlen(substr) - 1);
    }
    puts(str);

    return 0;
}
```

### 2.5 非法运算

除了上述相关运算外，指针运算都是非法的，如：指针间的加减乘除、位操作等。

## 三 指针一些常识

### 3.1 sizeof()测量指针大小

使用 sizeof()可以测量指针的大小，得到的总是：4 或 8，该值意义是指针变量指向存储地址的大小。

- 在 32 位平台，所有的指针（地址）都是 32 位(4 字节)
- 在 64 位平台，所有的指针（地址）都是 64 位(8 字节)

```c++
    char *p;
    printf("sizeof(p) = %d\n", sizeof(p));
    printf("sizeof(double *) = %d\n", sizeof(double *));
```

### 3.2 野指针和空指针

**空指针**：把 NULL 赋值给指针，表示此指针变量没有指向任何变量(空闲可用)。在指针解引用之前，必须确保它不是一个 NULL 指针。

```c++
    int *p = NULL;          // NULL是一个值为0的宏常量：#define NULL ((void *)0)
```

**野指针**：任意数值赋值给指针变量都没有意义（只要不越界即可，如 64 位 8 字节），因为这样的指针就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。由此可见，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。

野指针产生条件：

- 指针在刚创建时不会成为 NULL 指针，其缺省值是随机的，这样就会产生野指针。所以建议在创建指针变量时就要初始化。
- 指针在 free 或 delete 后未赋值 NULL，此时只是释放指针所指的内存，却没有杀死指针本身。所以建议在释放指针后设置指针为 NULL。
- 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。

野指针示例：

```c
    // 使用指针的常见错误就是指针在正确赋值前通过指针保存数据
    double d, *dp;
    *dp = 5.678;    // 数据被写入了一个未知地址
```

### 3.3 万能指针 `void *`

`void *` 指针可以指向任意变量的内存空间：

```c
    void *p = NULL;

    int a = 10;
    p = (void *)&a; //指向变量时，最好转换为void *

    //使用指针变量指向的内存时，转换为int *
    *( (int *)p ) = 11;
    printf("a = %d\n", a);           // 11
```

有些地址没有明确类型，其所指向的空间类型取决于后续应用，比如 malloc() 申请的内存：

```c
    void *malloc(size_t size);
```

### 3.4 const 修饰的指针变量

在编辑程序时，指针作为函数参数，如果不想修改指针对应内存空间的值，需要使用 const 修饰指针数据类型：

```c
    int a = 100;
    int b = 200;

    //指向常量的指针：修饰*，指针指向内存区域不能修改，指针指向可以变
    const int * p1 = &a;    // 等价于int const *p1 = &a;
    p1 = &b;                // 错误方式：*p1 = 111;

    //指针常量：修饰p1，指针指向不能变，指针指向的内存可以修改
    int * const p2 = &a;
    *p2 = 222;              // 错误方式：p2 = &b;
```

### 3.5 多级指针

C 语言允许有多级（也称为多重指针）指针存在，多级指针时指向指针的指针，如：二级指针就是指向一个一级指针变量地址的指针。

```c++
    int a = 10;
    int *p = &a; //一级指针
    *p = 100; //*p就是a

    int **q = &p;
    //*q就是p
    //**q就是a

    int ***t = &q;
    //*t就是q
    //**t就是p
    //***t就是a
```
