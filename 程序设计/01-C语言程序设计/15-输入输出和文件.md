# 15-输入输出和文件

## 一 输入/输出的基本过程和文件类型

文件是操作系统重对各类数据和输入/输出设备的一种抽象，是一种按照名字访问数据的机制。比如：磁盘上的数据存储文件、提供和现实数据的各类设备，都是通过文件机制被程序访问的。

每次数据的输入/输出，都必须指明数据的来源和去向，也就是该输入/输出操作所针对的文件。在对一个文件操作之前，需要打开该文件，以让操作系统为文件的操作分配所需要的资源。文件使用完毕后，需要关闭，以通知操作系统实际完成文件的操作，并回收资源。

在 C 程序开始运行时，有三个自动打开的标准文件：标准输入 stdin、标准输出 stdout、错误信息输出 stderr，可以省去对这些文件的说明和操作。

根据文件的内容和现实方式，一般将文件分为正文文件、二进制文件两种：

- 正文文件：用户可以直接阅读，包含可以打印的 ASCII 编码、空白符、控制字符等。如：.c 文件、.h 文件、html 文件、txt 文件等。
- 二进制文件：一般需要程序处理后才能显示，包含任意编码的字节。如：exe 文件、lib 文件、doc 文件、图片、音频等。

C 提供了大量的正文读写函数，如：`prinft()`、`scanf()`、`puts()`、`getchar()`等。

## 二 文件常见操作

### 2.1 文件的打开与创建

文件打开后创建了一个 FILE 类型的内部数据结构，用来保存该文件相关属性和资源，一般称为**字节流**：

```c
    FILE *fp = fopen("./1.txt", "r");
    if(fp == NULL){
        perror("Can't open file");  // 在标准错误上输出错误信息
        //...
    }
```

注意：Linux 平台的文件地址风格为： `/home/ry/democode/1.c`，Win 平台路径风格为： `D:\\democode\\1.c`。

fopen()的参数二为打开文件的方式：

- "r"：只读，文件不存在时打开失败
- "w"：只写，文件存在时内容会被清空
- "a"：追加，将数据追加到文件末尾，文件不存在时创建该文件
- "r+"：读写，读写位置在文件开始处
- "w+"：读写，当文件存在时内容会被清空
- "a+"：读和追加，将数据追加到文件末尾，文件不存在时创建该文件

注意：Win 平台还有字符 b 或者 t，分别表示按照二进制方式、正文方式 打开文件，与 Linux 平台差异较大。

### 2.2 文件的读写

操作标准文件的 I/O 函数有： `getchar()` `putchar()` `gets()` `puts()` `printf()` `scanf()` 等。操作指定文件的 I/O 函数往往以 f 开头，或者 c 结尾，如：`fget(c)` `getc()` `fgets()` `fprintf()` `fscanf()` 等。

### 2.3 读写操作中的定位

一般情况下，读写操作都是顺序进行：新读入的数据都是文件中紧跟在前一次读入数据后面的内容，而新输出的数据也紧接在文件中前一次写入数据的后面。但有时候，也需要在指定位置进行操作，如：视频文件是按帧保存的，当需要显示帧的时候，不可能一帧一帧的顺序读到要显示的帧，而是直接读取该位置上的帧，比如：数据在文件中以相同定长的记录形式保存，当需要对其中一些记录更新时，如果能直接在记录位置上更新，肯定性能是比把文件读到内存，再对其写入更高的。因此，C 语言的函数库提供了定位机制，以指定对文件读写操作的起始位置。

以读或者写方式打开的文件，系统会自动维护一个当前操作位置的标记，指明下一次读写操作的位置；以非追加方式打开的文件，位置初始值为 0，表示从起点开始，每完成一次读写操作，则标记就自动增加刚刚读写内容的字节长度。

相关函数有：

```c
// 定位函数
// 参数一：文件指针，参数二：起点开始的偏移量，单位为字节，参数三说明位移的起点，可以取值为 SEEK_SET SEEK_CUR SEEK_END
// 读取成功返回0
fseek(FIFLE *stream, long offset, int whence);

// 获取当前定位函数
long ftell(FIFLE *stream);

// 二者经常一起使用，用来计算与字符流长度相关的文件长度
fseek(fp, 0, SEEK_END);
len = ftell(fp);
```

示例：从文件中读出以正文形式表示的帧数，统计其中包含的字符数：

```c
int i, len , buf[BUFFSIZ];
FIFLE *p;

fp = fopen("./1.txt", "r");
for(i = 0; i < BUFFSIZ; i++){
    fscanf(fp, "%d", &buf[i]);
}
len = ftell(fp);
printf("读取了 %d， 当前位置: %d\n", i, len);
```

示例一：

```c
/**
 * 将正文文件的内容行行号逆序输出到标准输出中
 * 即：文件的最后一行首先输出，第一行最后输出，各行内容保持不变
*/
#include <stdio.h>

#define BUF_LEN 100
#define MAX_N 100

// 保存各行第一个字符在文件中的偏移量
long offset[MAX_N];

int main(){
    int i, n;
    char buf[BUF_LEN];
    FILE *fp;

    fp = fopen( "./1.txt", "r");
    if(fp == NULL){
        fprintf(stderr, "Can't open file");
        return 1;
    }

    for (n = 1; fgets(buf, BUF_LEN, fp) != NULL; n++){
        offset[n] = ftell(fp);
    }
    for (i = n - 1; i >= 0; i--){
        fseek(fp, offset[i], SEEK_SET);
        fgets(buf, BUF_LEN, fp);
        fputs(buf, stdout);
    }

    return 0;
}
```

上述问题最简单的思路是：将数据读入二维数组，然后逆序输出数组内容。但是当文件规模较大时，比如文件内有百万航，每行有上千个字符，这种做法显然不可行。

### 2.4 文件数据的二进制格式读写

对数据按二进制格式直接读写的函数是：

```c
// buf:即将读写和准备写出数据的存储区 size：每个数据项的长度，单位为字节
// nmemb 时被读写数据项的个数  stream 时与文件关联的字符流
// 调用成功后返回值是读入或写入的以size长度为单位的数据的项数（不是字节数）
sizet_t fread(void *buf, sizte_t size, sizte_t nmemb, FILE *stream);
sizet_t fwrite(const void *buf, sizte_t size, sizte_t nmemb, FILE *stream)

// 示例
// n保存的是10则表示有10个double类型的数据被读入buf中，那么实际操作的字节数是 10 * sizeof(double) = 80
n = fread(buf, sizeof(double), 10, fp);
```

二进制读写函数会把数据从文件中按照保存形式直接读入内存中，或者按照计算机内部表现形式直接写入文件中，往往是不需要人直接阅读的数据。优点是：

- 数据格式规范，占用空间小。比如计算机中大量的 int、double 或者以此为基础的自定义类型在内存中的长度与其转换为字符串之后的长度之间没有固定关系，在 32 位中，int 占据 4 个字节，而打印上都占据的位数却和整数值一样，如果使用二进制读写方式，则和内存表现一样固定占据 4 个字节磁盘空间。
- 函数运行效率高，因为不需要对数据格式进行转换，可以把数内存的数据整块的写入文件，或者从文件中读入内存。不过浮点类型数据则会因此产生为误差。~
