## 一 文件I/O 概述

在Linux中，一切皆文件，大部分设备都可以像操作文件那样使用，Linux的目录也是文件，但是很多现代操作系统不允许直接读取目录，所有用户都是使用上层：opendir、readdir接口来读取目录。  

Linux的文件操作函数，一般只需要理解五个系统调用：
- open：用于打开文件、设备
- close：关闭文件、设备
- read：从打开的文件、设备中的刦数据
- write：向文件、设备写入数据
- ioctl：把控制信息传递给设备驱动程序

在对文件进行读写之前，首先需要打开文件，内核会为每个进程维护一个打开文件的列表，即文件表（file table）。  

表中每一项都是一个打开文件的信息：
- 指向该文件索引节点的内存拷贝指针
- 关联的元数据，如文件位置指针、访问模式

文件表的索引称为文件描述符（fds：file descriptors），由非负整数表示，其范围从0开始，直到上限值减1（默认上限1024）。由于负数不是合法文件描述符，所以函数出错不能返回有效文件描述符时，通常返回-1。

每个进程都至少包含三个文件描述符（除非显示关闭这些描述符），如下所示：
- 0：表示标准输入 stdin，Linux中也使用宏 STDIN_FILENO 表示，代表连接到终端的输入设备，常为键盘
- 1：表示标准输出 stdout，Linux中也使用宏 STDOUT_FILENO 表示，代表终端的屏幕
- 2：表示标准错误 stderr，Linux中也使用宏 STDERR_FILENO 表示，代表终端的屏幕

用户可以重定向这些描述符，比如管道程序中，把一个程序的输出作为另一个程序的输入！文件描述符不仅仅用来访问普通文件，在Linux中，一切皆文件。使用文件描述符可以访问设备、管道、缓冲区FIFOs、套接字socket等。  

默认情况下，子进程会维护一份父进程的文件表副本，但当子进程关闭一个文件时，不会影响父进程的文件表。子进程和父进程也可以共享文件表（类似于线程间共享）。  

## 二 文件的所有权和权限

每个文件都有一个与之相关的用户 ID 和组 ID，分别定义文件的属主和属组。系统根据文件的所有权来判定用户对文件的访问权限。  

为了访问文件，系统把用户分为 3 类：
- 文件用户、
- 文件组（ group） ID 相匹配的文件用户
- 其他用户。 

可为以上 3 类用户分别设置 3 种权限（共计 9 种权限位）：
- 只允许查看文件内容的读权限；
- 允许修改文件内容的写权限；
- 允许执行文件的执行权限。

这里的文件要么指程序，要么是交由某种解释程序（通常指 shell 的一种，但也有例外）处理的脚本。也可针对目录进行上述权限设置，但意义稍有不同。读权限允许列出目录内容（即该目录下的文件名），写权限允许对目录内容进行更改（比如，添加、修改或删除文件名），执行（有时也称为搜索）权限允许对目录中的文件进行访问（但需受文件自身访问权限的约束）。  

## 三 文件 I/O 模型

Unix系统的I/O模型最注重通用性，即同一套系统调用（open，write等）所执行的I/O，可用于所有文件类型。不过就本质而言，内核只提供一种文件类型：字节流序列，在处理磁盘文件、磁盘或磁带设备时，可通过 `lseek()` 系统调用来随机访问。  

C语言中，I/O操作可以简单地看作是从程序移进或移出字节，这种搬运的过程便称为流(stream)。程序只需要关心是否正确地输出了字节数据，以及是否正确地输入了要读取字节数据。特定I/O设备的细节对程序员是隐藏的。  

流存在两种方式：
- 文本流：即以文本模式读取文件。例如在Windows系统中，文本文件约定以一个回车符和一个换行符结尾，在Linux下只使用一个换行符(`\n`)结尾。
- 二进制流：适用于非文本数据，其中的字节将完全根据程序编写的形式写入到文件中，不会做任何改变。  

C语言在处理这两种文件的时都会看成是字符流，按字节进行处理，不会有所区分。在程序中，文本方式打开文件和二进制方式打开文件仅仅体现在换行符的处理上。比如说，在Win下文件的换行符是`\r\n`，在Linux下换行符则是`\n`：
- 文件使用文本方式打开：Win系统中，文件中的换行符`\r\n`会被替换成`\n`读到内存中，写入文件的时`\n`被替换成`\r\n`再写入文件
- 文件使用二进制方式打开：Win系统中不进行`\r\n`和`\n`之间的转换，由于Linux下的换行符就是`\n`，所以文本文件方式和二进制方式无区别

## 四 文件指针

在C语言中用一个指针变量指向一个文件，该指针称为文件指针，通过文件指针才可对它所指的文件进行各种操作。   

文件指针在 `stdio.h`中声明如下：
```c
typedef struct {
	short           level;      //缓冲区"满"或者"空"的程度 
	unsigned        flags;      //文件状态标志 
	char            fd;         //文件描述符
	unsigned char   hold;	    //如无缓冲区不读取字符
	short           bsize;	    //缓冲区的大小
	unsigned char   *buffer;    //数据缓冲区的位置 
	unsigned        ar;	        //指针，当前的指向 
	unsigned        istemp;	    //临时文件，指示器
	short           token;	    //用于有效性的检查 
}FILE;
```

FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息。  

C语言中有三个特殊的文件指针由系统默认打开，用户无需定义即可直接使用，它们都是一个指向FILE结构的指针:
- stdin： 标准输入，默认为当前终端（键盘），我们使用的scanf、getchar函数默认从此终端获得数据。
- stdout：标准输出，默认为当前终端（屏幕），我们使用的printf、puts函数默认输出信息到此终端。
- stderr：标准出错，默认为当前终端（屏幕），我们使用的perror函数默认输出信息到此终端。

贴士：
- 在C语言中，EOF表示文件结束符(end of file)，以EOF作为文件结束标志的文件，必须是文本文件。ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。
- 当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个 `feof `函数，用来判断文件是否结束，如果读到了结尾，返回非0值，没有到文件结尾返回0。
- `feof`函数既可用以判断二进制文件又可用以判断文本文件。