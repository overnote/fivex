## 一 同步I/O

#### 1.1 深入理解读写

用户空间在发起write()调用时，会把数据拷贝到缓冲区，内核会收集所有的脏缓冲区，进行排序优化，然后再把缓冲区数据写入到磁盘上。所以write()可以频繁调用并立即返回。该方式支持内核把写操作推迟到空闲期，批处理很多写操作。  

同样，对还未写入磁盘，停留在缓冲区的数据执行读操作，会直接读取缓冲区数据，而不是读取磁盘数据！！！  

即数据的写入读取是从内存中触发的，可以极大提升效率。但是这样也会引起一些问题，比如写入磁盘时系统崩溃了，此时的错误无法发给写请求的进程！为了保证数据按时写入，内存设置了最大缓存时效（maximum buffer age），并在超出给定时效前将所有脏缓存的数据写入磁盘。  

#### 1.2 fsync()与fdatasync()

延迟写带来的极大的性能提升，但是有时希望控制何时把数据写到磁盘，Linux提供了一牺牲性能的同步操作！  

确保数据写入磁盘的系统调用是fsync()：
```
# 函数原型
#include <unistd.h>
int fsync(int fd);
int fdatasync(int fd);

# 返回值
-1：错误
0：成功
```

这2个函数都不保证：包含已变更文件的目录项会同步到磁盘上，即文件刚更新，数据也写入了磁盘，但是没有更新到相关的目录中，会导致文件不可用。为了保证对目录项的更新也都同步到磁盘上，必须对文件目录也嗲偶偶那个fsync进行同步操作。  

二者区别：
- fdatasync只会写入数据以及以后要访问文件所需要的元数据，不保证非基础的元数据也写到磁盘上，其速度更快，也能满足大多数场景
- fync还会写入文件修改时间戳等元数据，适合事务性更强的场景
- 在PSI标准中，fsync是必要的，fdatasync是可选的！！

fync通常会做2个I/O操作：回写修改的数据，更新索引节点的修改时间戳，由于索引节点和文件数据在磁盘上可能不是紧挨着，会带来代价极高的seek操作。

#### 1.3 sync()

sync() 用来对磁盘上的所有缓冲区进行同步，但是效率不高。
```
#include <unistd.h>
void sync(void);
```

该函数总是成功返回，并能确保所有缓冲区写入磁盘，包括：数据、元数据！但是：
- POSIX标准也不要求改函数等待！！！所以，一般建议多次调用sync()，确保完全写入
- Linux中完全相反，必须所有缓冲区都写入才会返回，因此调用一次sync()即可！

sync()一般用于同步功能的实现。

#### 1.4 O_SYNC标志位

读请求总是同步的，因为如果不同步，无法保证读取缓冲区的数据的有效性！但是写操作通常是非同步的，调用返回和数据真实写入磁盘无关。  

标志位 O_SYNC 可以把读写强制关联，保证write调用会执行I/O同步：
```
    fd = open(file, O_WRONLY | O_SYNC);
```

此时每次调用write()后，会隐执行类似fsync()的操作，然后才返回。比起直接使用fsync()和fdatasync()，O_SYNC开销更高！

POSIX标准还定义了O_DSYNC和O_RSYNC两个同步标志位，在Linux上，他们与O_SYNC完全一致，Unix有很大区别！

#### 1.5 直接I/O

类似数据库这样的系统往往希望使用自己的缓存，或者你的应用需要越过内核的缓存、缓冲等层次结构，进行独立的I/O管理，那么可以进行直接I/O（不过一般不推荐，因为操作系统本身已经做的足够好）。  

在open()中指定O_DIRECT标志位会使内核对I/O管理的影响最小化，即忽略页缓存机制，直接对用户孔家缓冲区和设备进行初始化，这时所有的I/O操作都是同步的，完成之前不返回！  

## 二 lseek()查找函数

一般情况下，I/O是线性的，且读写会引发隐式的seek操作，即文件位置更新。如果要跳跃式读取文件，需要利用lseek函数将文件描述符的位置指针设置为指定的值。  

注意：lseek()只更新文件位置，没有更新其他操作，也不初始化任何I/O。  

```c
#include <sys/types.h>
#include <unistd.h>
off_t lseek(int fd, off_t pos, int origin);
```

origin参数的值：
- SEEK_CUR：文件位置设置为当前值，再加上pos个偏移值，如果pos=0，则返回当前文件位置值
- SEEK_END：文件位置设置为文件长度，再加上pos个偏移值，如果pos=0，则设置成文件末尾
- SEEK_SET：将文件位置设置为pos值，错误时返回-1，并设置响应errno

示例：
```c
    // 将fd的文件位置指针设置为1825
    ret = lseek(fd, (off_t)1825, SEEK_SET);
    // 将fd的文件位置设置为文件末尾
    ret = lseek(fd, 0, SEEK_END);
    // lseek()返回更新后的文件位置，可以通过SEEK_CUR，把便宜pos设置为0，确定当前文件位置
    pos = lseek(fd, 0, SEEK_CUR);
```

lseek()支持文件末尾之后继续查找，如下所示定位到文件末尾之后的1688个字节
```c
    ret = lseek(fd, (off_t)1688, SEEK_END);
```
此时读取新文件位置会得到EOF，但是如果执行写请求，那么会在文件的旧长度和新长度之间用0来填充！这种零填充区间叫做”空洞hole“，空洞不会占据物理磁盘空间，所以文件大小可能会超过磁盘的物理大小。包含空洞的文件称为”稀疏文件sparse file“，稀疏文件可以节省很多空间，提升性能，因为操作空洞不会产生物理I/O。  

## 三 定位读写

Linux提供了pread()和pwrite()函数替代lseek()，在完成时，不会更新文件位置：
```c
#define _XOPEN_SOURCE 500
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t count, off_t pos);
ssize_t pwrite(int fd, const void *buf, size_t count, off_t pos);
```

注意：这2个函数可以避免使用lseek()时引起的竞争！  

## 四 文件截短

Linux提供了2个文件长度截短系统调用：
```c
#include <unistd.h>
#include <sys/types.h>
int ftruncate(int fd, off_t len);
int truncate(const char *path, off_t len);
```

2个函数都会将文件截短为len长度，但是不会修改当前文件位置。