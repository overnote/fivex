# 09-指针

## 一 指针概述

### 1.1 指针定义

通过变量名或者数组名可以直接对数据实体进行读写操作，不过如果知道这些实体数据的地址也能找到相应数据，即通过地址绕过数据实体的名称对数据进行访问。

由于数据实体的地址指向其所在的内存空间，可以称为指针。

贴士：当程序运行时，函数的代码也是存储在内存内的，因此代码的入口地址也是指针。

指针主要有两个重要属性：

- 指针指向哪个数据实体
- 指针具有什么样的数据类型

例：double 类型的变量 a 的地址是一个指向变量 a 的指针，其类型是一个指向 double 类型的指针。

一个合法的具有指针类型的数据必须指向一个完整的数据实体，如：变量、数组、数组元素、函数等。对于单位长度为多字节的数据实体，如 int 或 double 类型的变量，其地址是其第一个字节的地址！

例：

```c
double a, b;
int i;
short x, y;
unsigned int arr[6];
char s[8];
```

上述变量在内存中的地址表现如下所示：

![内存地址](../images/c/09-01.svg)

在上图中，在分割线上的地址都是合法指针，如：0x1230,0x1238,0x1240,0x1246,0x125c,0x1261 等，分别是 a,b,i,y,arr[5],s[1]的地址，而 0x123c 和 0x1256 则是不合法的指针。

**总结：指针是一种数据类型，其实质就是内存地址。在开发中如果要使用一些数据的内存地址，需要用一个变量来保存该地址，这个变量称为指针变量。**

### 1.2 数据实体地址获取

C 语言使用 `&` 获取数据实体地址，例如变量 a 的地址获取方式是：`&a`，数组元素 arr[2]的地址为 `&arr[2]`。

对于函数来说，函数名本身就是该函数入口代码在内存中的地址，是一种具有指针类型的数据，因此无需使用&获取，同理数组名本身是该数组第一个元素的地址，因此一般情况下对数组也不使用运算符&。

## 二 指针变量

### 2.1 指针变量定义和赋值

指针变量定义格式：`<类型> *<变量名>`，\*说明变量名是个指针，类型说明了该指针指向的数据实体的数据类型。

类型相同的指针变量之间可以互相赋值。

示例：

```c++
    int a = 0;
    printf("%p \n",&a);         // &a 查看a的地址

    // *p 定义指针e变量
    int *p = NULL;              // p是变量名， int * 是指针类型
    p = &a;               // 将a的地址赋值给p
    printf("%d \n",*p);   // p指向了a的地址，*p就是a的值

    // 通过指针间接修改变量的值
    *p = 100;
    printf("%d \n",*p);
```

指针使用贴士：

- 声明指针时，`*` 表示所声明的变量为指针类型
- 使用指针时，`*` 表示操作指针所指向的内存空间

### 2.2 指针访问数据

指针所表示的是存储地址，而非数据本身，使用符号 \* 后才能获取到数据：

```c
int d, e = 8;
d = *&e;
*&e = 10;
```

上述 2 个赋值语句分别等价于 d = e 和 e = 10。

## 三 指针运算

### 3.1 指针与整数的加减

对于数组中的某个元素的指针，加上一个整数 n 表示让其指向当前位置后面第 n 个元素，减去一个整数 n 则表示是其指向前面第 n 个元素。如指针变量：`p = arr[5]`，当 p = p + 3 后实际上指向了下标为 8 的元素。

### 3.2 指针相减

只有指向同一数组中元素的指针之间才可以相减，得到的结果是一个 int 型的整数，表示这两个指针所指向元素之间下标之差：

```c
    int a, b, arr[] = {0, 1, 2, 3, 4, 5}, *p1 = &arr[1], *p2 = &arr[5];
    a = *(p1++);    // 1
    b = (*p2)++;    // 5
```

### 3.3 运算符结合

C 语言规定 * 和后置的 ++/-- 一起出现时，需要从右向左结合。所以 `*p++`与`*(p++)`等价，表示++作用域指针变量p，而`(*p)++` 表示++作用域变量 p 所指向的变量。

### 3.4 指针的比较

2 个指针间比较是否相等：可以判断是否指向同一个元素。

指针与 0 比较是否相等：可以用来判断指针是否有效，C 语言头文件中定义了一个等于 0 的符号常量 NULL。

示例 1：从标准输入上读入 N（`0<N<1000000`）行数据，每行含有 n 个由空白符分隔的实数。在标准输出上输出每个输入行的行号、数据的数量以及该行数据平均值，每行输入数据对应一个输出行，行号与数据数量之间以冒号分隔，数据数量与数据平均值之间以空格符分隔。

```c
char *get_value(char *s, double *d){
    while(*s != '\0' && isspace(*s)){
        s++;
    }
    if(sscanf(s, "%lf", d) != 1){
        return NULL;
    }
    while(*s != '\0' && !isspace(*s)){
        s++;
    }
    return s;
}

int main(){
    int i, n;
    double d, subsum;
    char buf[BUFSIZ], *p;

    for(i = 1; fgets(buf, BUFSIZ, stdin) != NULL; i++){
        subsum = 0;
        for(n = 0; p = buf; (p = get_value(p, &d)) != NULL; n++){
            subsum += d;
        }
        if(n > 0){
            prinft("%d:%d %f\n", i, n, subsum / n);
        }
    }

    return 0;
}
```

示例 2：从标准输入上读入以空格分隔的字符串 s 和 t，将 s 中首次与 t 匹配的子串逆置后再输出 s，当 s 中无与 t 匹配的子串时直接输出 s。例如：当 s 和 t 分别为 helloworld 和 wor 时，输出 hellorowld。

```c
void rev(char* first char* last){
    int tmp;
    while(first < last){
        tmp = *last;
        *last = *first;
        *first = tmp;
        first++, last--;
    }
}

int main(){
    char str[BUFSIZ], substr[BUFSIZ], *p;

    scanf("%s%s", str, substr);
    if((p = strstr(str, substr)) != NULL){
        rev(p, p + strlen(substr) - 1);
    }
    puts(str);

    return 0;
}
```

### 3.5 非法运算

除了上述相关运算外，指针运算都是非法的，如：指针间的加减乘除、位操作等。

## 四 指针一些常识

### 4.1 sizeof()测量指针大小

使用 sizeof()可以测量指针的大小，得到的总是：4 或 8，该值意义是指针变量指向存储地址的大小。

- 在 32 位平台，所有的指针（地址）都是 32 位(4 字节)
- 在 64 位平台，所有的指针（地址）都是 64 位(8 字节)

```c++
    char *p;
    printf("sizeof(p) = %d\n", sizeof(p));
    printf("sizeof(double *) = %d\n", sizeof(double *));
```

### 4.2 野指针和空指针

**空指针**：把 NULL 赋值给指针，表示此指针变量没有指向任何变量(空闲可用)。NULL 指针并未指向任何东西，因为对一个 NULL 指针因引用是一个非法的操作，在解引用之前，必须确保它不是一个 NULL 指针。

```c++
    int *p = NULL;          // NULL是一个值为0的宏常量：#define NULL ((void *)0)
```

**野指针**：任意数值赋值给指针变量都没有意义（只要不越界即可，如 64 位 8 字节），因为这样的指针就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。

野指针产生条件：

- 指针在刚创建时不会成为 NULL 指针，其缺省值是随机的，这样就会产生野指针。所以建议在创建指针变量时就要初始化。
- 指针在 free 或 delete 后未赋值 NULL，此时只是释放指针所指的内存，却没有杀死指针本身。所以建议在释放指针后设置指针为 NULL。
- 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。

野指针示例：

```c
// 使用指针的常见错误就是指针在正确赋值前通过指针保存数据
double d, *dp;
*dp = 5.678;    // 数据被写入了一个未知地址
```

### 4.3 万能指针 void \*

void \*指针可以指向任意变量的内存空间：

```c
 void *p = NULL;

 int a = 10;
 p = (void *)&a; //指向变量时，最好转换为void *

 //使用指针变量指向的内存时，转换为int *
 *( (int *)p ) = 11;
 printf("a = %d\n", a);           // 11
```

有些地址没有明确类型，其所指向的空间类型取决于后续应用，比如 malloc() 申请的内存：

```c
void *malloc(size_t size);
```

### 4.4 const 修饰的指针变量

在编辑程序时，指针作为函数参数，如果不想修改指针对应内存空间的值，需要使用 const 修饰指针数据类型：

```c
 int a = 100;
 int b = 200;

    //指向常量的指针：修饰*，指针指向内存区域不能修改，指针指向可以变
 const int * p1 = &a;    // 等价于int const *p1 = &a;
 p1 = &b;                // 错误方式：*p1 = 111;

    //指针常量：修饰p1，指针指向不能变，指针指向的内存可以修改
 int * const p2 = &a;
 *p2 = 222;              // 错误方式：p2 = &b;
```

## 五 指针与数组

### 5.1 数组指针

数组地址其实就是首元素地址：

```c++
    int arr[] = {1,2,3,4};

    // 二者值一致
    printf("%p\n", arr);
    printf("%p\n", &arr[0]);

    //a = 10; //err, 数组名只是常量，不能修改
```

指针类型与数组类型在大多数场合都可以互换使用，但是他们仍然是不同的类型，主要区别有三点：

- 1、数组是一片连续的存储空间，在定义的时候已经为所有的数组元素分配了位置，而指针只是一个保存数据地址的存储单元，未经正确赋值之前不指向任何合法的存储空间，因此不能通过它进行任何数据访问。此时赋值会产生野指针。
- 2、通过数组所能访问的数据的数量（元素个数）在数组定义时就已经确定，而指针所能访问的数据的数量取决于指针所指向的存储空间的性质和规模。
- 3、数组名是一个常量而不是一个变量，不能被赋值。

在 C 程序中经常利用指针与数组的可互换性来支持数组的负数下标，语法上不合法，但是如果一个指针指向数组中间的某个元素，则可以将改数组作为一个可以支持负数下标的数组来使用：

```c
/**
 * 从标准输入上读入两行由不超过100位数组构成的字符串，计算2个字符串表示的正整数和
 * 解析：
 * 常规计算机无法处理超过20位的整数，超长数值运算也称为高精度运算。
 * 一般需要将数据逆序读入为字符数组，按位操作，最后再逆序输出字符串化的结果。
 * 数据的最高位对应数组下标为0，数组下标随着数位权重递减而递增，所以可以使负数下标。
 */
#include <stdio.h>
#include <string.h>

char a[N], b[N];// N 需要大于所需处理的最大数的长度

int main(){
    // 用于计算的数字字符串p和q
    char *p, *q, *t;
    int i, len_p, len_q, tmp;
    // PAD 是大于等于1的整数，说明在读入数字串前端保留用于加法进位的数组元素数量
    p = &a[PAD];
    q = &b[PAD];
    scanf("%s%s", p, q);
    len_p = strlen(p);
    len_q = strlen(q);

    // 使指针指向字符串的末尾
    if(len_p >= len_q){
        p += len_p - 1;
        q += len_q - 1;
    } else {
        t = q;
        q = p + len_p - 1;
        p = t + len_q - 1;
        tmp = len_q;
        len_p = len_q;
        len_q = tmp;
    }

    for (i = 0; i > -len_q; i--){
        p[i] += q[i] - '0';
    }

    for (i = 0; i > -len_p; i--){
        if((p[i] - '0') >= 10){
            p[i - 1] += (p[i] - '0') / 10;
            p[i] = (p[i] - '0') % 10  + '0';
        }
    }

    if(p[i] != 0){
        p[i] += '0';
    }else {
        i++
    }

    printf("%s\n", &p[i]);

    return 0;
}
```

### 5.2 指向二维数组的指针

指向二维数组的指针，其指向的数据实体是二维数组中的一行元素，即一个一维数组，其包含的元素个数等于二维数组的列数。所以定义一个二维数组需要指明其列数，而与其行数没有关系：

```c
double arr1[32][64], arr2[64][128], arr3[16][128];
double (*ap)[64], (*bp)[128], (*cp)[128];

// ap指针指向了arr1中下标为0的行，此时ap和arr1等价
ap = arr1;
// 此外：*ap、ap[0]等价于arr1[0], (*ap)[3]、*(*ap + 3)、ap[0][3]都等价于 arr1[0][3]

// bp可以指向arr2,arr3，或者数组中的任意一行，因为这2个数组的元素类型以及列数与bp定义相同
bp = arr2;
bp = &arr3[5];
// 此外：bp等价于从arr3[5]开始的二维数组：*bp、bp[0]等价于arr3[5]，(*bp)[3]、*(*bp + 3)、bp[0][3]等价于arr3[5][3]

cp = &arr3[8];
```

与一维数组指针类似，二维数组指针加减一个整数 n 就等于指向原来位置后面或者前面第 n 行，示例中 `ap--`、`--bp` 其实会分别使 ap 和 bp 指向前一行。

当指向同一数组的二维指针相减时，若结果是一个整数，表示 2 个指针所指向的内容相差的行数。比如示例中 bp 指向 arr3 的第五行，cp 指向 arr3 下标为 8 的行，所以`cp-bp=3`。

与一维数组类似，二维数组作为函数参数也可以声明为指针类型：

```c
// 二者等价
void arr_add(int t1[][5], int t2[][5], int s[][5]);
void arr_add(int (*t1)[5], int (*t2)[5], int *(s)[][5]);
```

### 5.3 指针数组

元素类型为指针的数组即为指针数组。指针数组定义时需要在类型和数组名之间加上 `*` 号：

```c
int *p[100];

// 也可以在定义时初始化：但此时指针数组初始化表中只能包含变量的地址、数组名、无效指针的常量NULL
double d1[100], d2[200], d3[300], avg, sum;
double *dp[] = {d1, d2, d3, &avg, &sum, NULL};  // 6个double类型的指针数组
```

示例：

```c
/**
 * 使用指针数组设计函数 week_day()，已经某月x日是星期y，该月有n天，该函数输出下一个月k日是星期几
 */
char *week_days[] = {
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
}

void week_day(int x, int y, int n, int k){
    int m;
    m = (n - x + y + k) % 7;
    printf("%s\n", week_days[m]);
}
```

指针数组与二维数组区别：

- 1、指针数组中只为指针分配了存储空间，其指向的数据元素所需要的存储空间是通过其他方式分配的
- 2、二维数组每一行中元素的个数是在数组定义时明确规定的，并且是完全相同的，而指针数组中各个指针所指向的存储空间的长度不一定相同
- 3、二维数组中全部元素的存储空间是连续排列的，而指针数组中只有各个指针的存储空间是连续排列的，指针所指向的数据元素的存储排列顺序取决于存储空间的分配方法。

指针数组经常用于复杂程序中，用来作为各种数据的索引，以便有效的组织数据、简化程序、提升运行速度。比如要对二维数组进行排序时，如果字符串 A 和字符串 B 需要进行交换顺序，那么需要字符串 A 复制到一个临时缓冲区，然后把 B 复制到 A 原来的位置上，最后从缓冲区取将 A 的字符串复制到 B 上。如果字符串长度较长，交换次数较多，则操作效率会变低，如果利用指针数组作为索引对字符串数组进行排序，则只需要交换着两行所对应的指针即可。

## 六 指针与函数

### 6.1 函数形参改变实参值

C 语言中的函数都是值传递的，所以一般在函数内部对形式参数进行修改不会影响函数外部变量，为了绕过限制，通过指针类型的参数，从内部可以间接操作函数外部变量。

贴士：指针类型的函数参数与函数参数的值传递没有冲突，因为指针依然是以值传递方式传递给函数的，只不过传递的不是数值，而是变量的地址。

```c++
#include <stdio.h>

void swap1(int x, int y){
 int tmp;
 tmp = x;
 x = y;
 y = tmp;
 printf("x = %d, y = %d\n", x, y);
}

void swap2(int *x, int *y){
 int tmp;
 tmp = *x;
 *x = *y;
 *y = tmp;
}

int main(){

// 值传递
 int a = 3;
 int b = 5;
 swap1(a, b);
 printf("a = %d, b = %d\n", a, b);

// 地址传递
 a = 3;
 b = 5;
 swap2(&a, &b);
 printf("a2 = %d, b2 = %d\n", a, b);

 return 0;
}
```

### 6.2 数组名做函数参数

数组名做函数参数，函数的形参会退化为指针，所以在函数的参数列表里不需要声明数组元素的个数。无论是形参还是实参，指针和数组在语法上是等价的：

```c++
#include <stdio.h>

void printArrary(int *a, int n) {
 int i = 0;
 for (i = 0; i < n; i++)
 {
  printf("%d, ", a[i]);
 }
 printf("\n");
}

int main(){
 int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
 int n = sizeof(a) / sizeof(a[0]);

 //数组名做函数参数
 printArrary(a, n);
 return 0;
}
```

#### 4.3 指针做为函数的返回值

```c
#include <stdio.h>

int a = 10;

int *getA(){
 return &a;
}


int main(){
 *( getA() ) = 111;
 printf("a = %d\n", a);

 return 0;
}
```

### 6.3 函数指针变量

函数名其实表示的是一个函数的可执行代码入口，也就是指向该函数可执行代码的指针。函数的指针类型其实是一个泛称，其具体类型由函数的原型决定：

```c
// 定义一个函数指针，名称为fp，指向的函数有2个double参数
double (*fp)(double x, double y);
// 上述定义可以省略为：
double (*fp)(double, double);

// 定义了函数指针之后就可以对其进行复制类型相同的函数
double sum(double x, double y){
    return x + y;
}
fp = sum;

// 赋值后fp指针保留了sum的入口地址，此时可以直接作为函数使用
(*fp)(10, 20);

// 为了方便，在C语言中也允许直接使用函数指针变量
fp(10, 20);
```

函数指针可以提升代码的可扩展性，可重用性，比如在一些框架中，由一些函数提供基本的、与具体数据或类型无关的计算过程，这些函数被调用时，由其他函数提供与具体数据或类型相关的计算功能。比如标准库中的：

```c
// qsort 用于数组排序，但是不针对任何数据类型，也不预先设定排序规则，均由用户决定
// base 是需要排序的数组指针，num是数组元素个数，wid是每个元素所占用字节数
// comp是一个指向数组元素比较函数的指针，其参数是2个未知的指针，返回负数、正数、0，分别代表第一个参数所指向元素在顺序上先于、后于、等于第二个参数指向元素
void qsort(void *base, size_t num, size_t wid, int (*comp)(const void *e1, const void *e2));
```

qsort 使用示例：

```c
// 升序排列：通用指针方式，需要转换
int rising_double(const void *p1, const void *p2){
    if(*(double *)p1 > *(double *)p2){
        return 1;
    }
    if(*(double *)p1 < *(double *)p2){
        return -1;
    }
    return 0;
}

// 降序排列：double指针
int falling_double(const double *p1, const double *p2){
    if(*p1 < *p2){
        return 1;
    }
    if(*p1 > *p2){
        return -1;
    }
    return 0;
}

qsort(arr, ARR_LEN, sizeof(double), rising_double);
qsort(arr, ARR_LEN, sizeof(double), falling_double);
```

## 七 多级指针

C 语言允许有多级（也称为多重指针）指针存在，多级指针时指向指针的指针，如：二级指针就是指向一个一级指针变量地址的指针。

```c++
 int a = 10;
 int *p = &a; //一级指针
 *p = 100; //*p就是a

 int **q = &p;
 //*q就是p
 //**q就是a

 int ***t = &q;
 //*t就是q
 //**t就是p
 //***t就是a
```
